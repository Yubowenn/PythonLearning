# 深拷贝和浅拷贝
## 1 浅拷贝
copy函数是浅拷贝，只对可变类型的第一层对象进行拷贝，对拷贝的对象开辟新的内存空间进行存储，不会拷贝对象内部的子对象。
* 不可变类型的浅拷贝示例代码:

a1和b1两个地址一样，不可变类型进行浅拷贝不会给拷贝的对象开辟新的内存空间，而只是拷贝了这个对象的引用。注意：但是由于整型是不可变类型，如果对a1重新赋值，则a1的地址发生了改变。
```python
import copy  # 使用浅拷贝需要导入copy模块

# 不可变类型有: 数字、字符串、元组

a1 = 123123
b1 = copy.copy(a1)  # 使用copy模块里的copy()函数就是浅拷贝了，类似于b1 = a1
# 查看内存地址
print(id(a1))
print(id(b1))

a2 = (1, 2, ["hello", "world"])
b2 = copy.copy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))
```

* 可变类型的浅拷贝示例代码：可变类型进行浅拷贝只对可变类型的第一层对象进行拷贝，对拷贝的对象会开辟新的内存空间进行存储，子对象不进行拷贝。
```python
import copy

a = [1, 2, [4, 5]]
# 注意：浅拷贝只会拷贝父对象，不会对子对象进行拷贝
b = copy.copy(a) # 使用copy模块里的copy()函数就是浅拷贝了
c = a # 赋值操作
# 查看内存地址
print("====父对象内存地址====")
print(id(a))
print(id(b))
print(id(c))
# 查看子对象内存地址
print("====子对象内存地址====")
print(id(a[2]))
print(id(b[2]))
print(id(c[2]))

# 修改数据1
a.append(4)
# 父对象对象的数据不会受影响
print("====修改父对象====")
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')

# 修改数据2
a[2].append(6)
# 子对象的数据会受影响
print("====修改子对象====")
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')


# 输出：
# 4336681600
# 4335321344
# 4336675392
# 4336675392
# a: [1, 2, [4, 5, 6]]
# b: [1, 2, [4, 5, 6]]
# a: [1, 2, [4, 5, 6], 4]
# b: [1, 2, [4, 5, 6]]
```

## 2 深拷贝
deepcopy函数是深拷贝, 只要发现对象有可变类型就会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。
* 不可变类型的深拷贝示例代码：
```python
import copy  # 使用深拷贝需要导入copy模块

# 不可变类型有: 数字、字符串、元组

a2 = "张三"
b2 = copy.deepcopy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))
print("-" * 10)

a3 = (1, 2)
b3 = copy.deepcopy(a3)
# 查看内存地址
print(id(a3))
print(id(b3))
print("-" * 10)

# 注意: 元组里面要是有可变类型对象，发现对象有可变类型就会该对象到最后一个可变类型的每一层对象进行拷贝
a4 = (1, ["李四"])
b4 = copy.deepcopy(a4)
# 查看内存地址
print(id(a4))
print(id(b4))
# 元组里面的可变类型子对象也会进行拷贝
print(id(a4[1]))
print(id(b4[1]))


# 输出：
# 4317818576
# 4317818576
# ----------
# 4317686336
# 4317686336
# ----------
# 4319409344
# 4319284608
# 4319357632
# 4318004224
```
不可变类型进行深拷贝如果子对象没有可变类型则不会进行拷贝，而只是拷贝了这个对象的引用，否则会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。

* 可变类型的深拷贝示例代码：
```python
import copy  # 使用深拷贝需要导入copy模块

# 可变类型有: 列表、字典、集合

a1 = [1, 2]
b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了
# 查看内存地址
print(id(a1))
print(id(b1))
print("-" * 10)
a2 = {"name": "张三"}
b2 = copy.deepcopy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))
print("-" * 10)
a3 = {1, 2}
b3 = copy.deepcopy(a3)
# 查看内存地址
print(id(a3))
print(id(b3))
print("-" * 10)

a4 = [1, 2, ["李四", "王五"]]
b4 = copy.deepcopy(a4)  # 使用copy模块里的deepcopy()函数就是深拷贝了
# 查看内存地址
print(id(a4))
print(id(b4))

# 查看内存地址
print(id(a4[2]))
print(id(b4[2]))
a4[2][0] = "王五"
# 因为列表的内存地址不同，所以数据不会收到影响
print(a4)
print(b4)

# 输出：
# 140348291721736
# 140348291721928
# ----------
# 140348311762624
# 140348311221592
# ----------
# 140348311457864
# 140348291752456
# ----------
# 140348291723080
# 140348291723144
# 140348291723208
# 140348291723016
# [1, 2, ['王五', '王五']]
# [1, 2, ['李四', '王五']]
```
可变类型进行深拷贝会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。
## 3 深拷贝和浅拷贝的对比
* 浅拷贝最多拷贝对象的一层，深拷贝可能拷贝对象的多层
